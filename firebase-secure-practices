
I can hack into your firebase app in about 10 seconds then steal and delete all your data assuming you fail to set up back-end security rules allow me to show you all I have to do is pull up an app and go into the chrome developer tools under the network tab then find a request coming from firebase open up the headers and find the corresponding project ID from there I can just go to the command line and run a curl delete request to the firebase REST API and start wiping out this app's database if

you deploy a firebase app without backend rules anybody can do this to your app as well today I'm going to show you how to keep your firestore database secure by writing expressive easy-to-understand back-end security rules if you're new here like and subscribe and grab the source code from angular firebase comm to get started you'll want to go to the firestore database and then open up the rules tab rules are defined in their own special language that somewhat resembles JavaScript currently the arrows pointing

to the root of our database and all of our rules logic will be defined inside this block then we use the match keyword to point two paths in our database where we want to apply rules in this case we're using that equals star star to match every single document in the database then we use the allow keyword followed by the operation that we want to set a rule for in this case reader right if we leave it blank it's going to allow those operations or we can write an expression that returns true or false

to apply some actual rule logic to this route for example if we wanted to completely lock down all documents we could say if false and then nobody could read or write from the client-side if I try to query a collection from my front-end app I'm going to get an error in the browser console so cool now our apps 100% secure but that's a little too secure now we're going to write some rules that perform logic based on user authentication the underlying data the incoming request time etc first let's

look at the various types of requests that we can lock down first we have get which would apply to reading a specific document then list would apply to a collection query so those are our read rules then our write rules we have create which applies to creating new data update for modifying existing data and delete for removing data in addition we could say allow read which would just combine getting lists or we could also say allow right which would can buy and create update delete into a single rule

so that's how we scoped rules to specific operations now I want to show you how to point to the actual data that we want to apply these rules to the first thing to make note of is the equal star star that special syntax is going to tell your rules to cascade down to all sub collections and anything nested under that path that's useful when you have a rule that's applied to many different collections such as verifying a user is authenticated you can also make your rules very specific for

example we can point to a specific document using that document ID all you have to do is hard code it directly into the path and then write the corresponding rules that can be useful sometimes but the single most useful matcher is the wild-card ID instead of hard-coding the ID we just add brackets with a variable name that we can evaluate as the ID at runtime by setting product ID right here we can use that as a variable that represents the document ID then we can evaluate that ID in the actual allow statement which will see an

action here throughout the lesson and the wild-card is by far the most common matcher that you're going to be using throughout your back-end rules I'd also like to point out that your rules are secure by default so unless you explicitly allow an operation it's going to be blocked by firestore and my demo here I'm allowing the user to read the documents but only delete a document if they are logged in we can figure that out by looking at the request object that is built into the rules environment

the request object is very important and for one it gives us information about the current user to simply see if the users logged in we can see if the request off does not equal null so that's pretty cool but the thing I don't like about it is that it doesn't read very well that brings me to my favorite part of firestore rules and that's the ability to write your own custom functions functions allow us to repurpose our rules in a way that's dry and readable so instead of writing if

request auth does not equal null a whole bunch of times I'm going to write a function called is signed in the function will just return the request auth does not a null statement then we can replace it on the allow line and now it just reads like a plain English sentence that anybody can understand allow delete if signed in pretty simple my goal from here on out is to give you a bunch of helper functions that you can easily reuse in your own project the next thing we might want to do is determine whether

or not a user is the owner of a certain document a good example might be a user profile where all users can read other users profiles but only the owner can write to it so here we're matching the users user ID document and allowing read if they're signed in but only allowing write if they're the owner user and notice how we're passing the wild card variable to the argument in our function for this to work it's important that the document ID matches the user ID and if you've seen my authentication tutorials

you'll know how to do that then when defining this function all we have to do is look at the auth user ID on the request and compare it to the user ID on that document that we passed as the argument if the IDS are the same then we know that the current user is the owner of this document and we can actually get a lot more sophisticated let's say we want to determine whether or not a user has a verified email I'm going to use an and statement to chain another function to our rule with an and statement both

functions will need to return true for this rule to pass you can also change things together with an or statement to check if only one of the conditions is true but in this case we want to make sure that users the owner and that they have a verified email like I mentioned before the request object has all kinds of useful information in this case we're going to look at the token on the auth object that contains an email verified property of true or false we can also see when a user signed up if they're

anonymous if they have a phone number to compose all kinds of other useful rules but another common thing you'll need in your rules is to know what the existing data looks like as compared to the incoming data to get the existing data you can use the resource keyword followed by data but try not to confuse that with request resource data I recommend writing functions as existing data and incoming data just to make this very explicit and clear because these are easy to mix up and it's really important that you don't

mess up your back-end rules so when might you need existing data a common use case would be if you have a certain document that maybe gets locked after it's published if we jump up to the products path we can look at the existing product document and we'll make sure that it's not locked before running the update checking existing data is usually most important when your users can control whether or not a document should be modified at some point when it comes to incoming data there's all kinds

of validation rules that we can apply to our underlying data structure let's imagine that our product document of greater than $10 so if the user tries to send an update where the price is less than $10 we're going to cause this update to fail so looking at the incoming data is very important for maintaining the integrity of your database now switching gears in episode 75 I talked about rule-based user authorization and I want to revisit some of those concepts now in that lesson we saved information about the user's role

on their user document and we need to read that document when applying a rule to various parts of the database this documents not going to be available on the user object so we're going to need a different mechanism to read the document whenever needed the rules environment has a get keyword that will read a document by pointing to a specific path we need to use the absolute path so this gets pretty verbose but if you put it into a function then it's not too bad we write out the path like normal and then

use dollar sign parentheses and interpolate the request auth user ID this gives us the current users document and firestore which contains information about their authorized roles now let's use this function to authorize a user to update a product we can read the document and then we have an object of roles so we can get all of the keys from that object by calling keys on it then has any will check if the user has any of these authorized roles such as editor or admin you can also use has all to

make sure that the user has all of these roles at the end of the day that gives you a very simple solution for implementing rule-based user authorization another interesting thing to think about is how time impacts your database security a common scenario is to throttle the amount of data that a user can create during a certain duration of time we can get the current time of any request by just calling request time then there's a duration helper that we can use to operate on the time stamp for example we

want to make sure the request time comes after the created at time stamp plus a duration of 60 seconds in other words the user can only write to a product document every 60 seconds so duration just allows you to add a number of seconds minutes or hours and compare them to a firestore timestamp I'm going to go ahead and wrap up there hopefully this helps you avoid becoming the next major data breach victim if this video helped you please like and subscribe and if you're ready to take things to the

next level consider becoming a pro subscriber at angular firebase calm you'll get a whole bunch of exclusive content and direct access to chat with me on slack thanks for watching and I'll see you soon


firebase security when you build a firebase app you can perform user authentication and work with your database entirely from your front-end code but how is this possible if our database is exposed on the client wouldn't that mean that any hacker could then read or write private user data the answer is no because your infrastructure is protected by a mechanism known as firebase security rules which can be applied to real-time database cloud storage and firestore in a traditional web application you have a

server on that server you implement security logic that uses either tokens or cookies to verify that a user making a request is authorized to do so firebase rules achieve the same thing but without the need to write maintain and deploy server-side code instead you create a policy to define who has access to what in your database using a very easy to learn language called common expression language whenever a user makes a request to read or write to your database that request is routed through this policy

every operation is denied by default when a request comes in it will look for the first rule to allow it once allowed firebase can then securely read or write to your database you can write rules from the firebase console or your ide in the console you can time travel back to any previous rules you've used in the past or use the playground to send a mock request to your database and in production you can analyze exactly how your rules are being executed to enforce a rule we start by matching a

path in the database which can be as broad as the entire database or as granular as a single document a single document can be matched with a collection followed by a document id if we want anybody to read and write to this document we can say allow read and write but that's not very secure let's make sure a user is logged into our app to view the document which we can do by writing conditional logic we allow the operation if the request auth object does not equal null when it comes to writes we

can make sure only the user that owns the document can write to it by checking the request auth user id in most cases though you'll want your rules to apply to an entire collection if we wrap the document id in braces the rule now applies to any document in that collection and we can use the document id as a variable in our logic and now we have a firebase app that's 100 secure without any vulnerabilities whatsoever but there's a lot more to learn consider becoming a pro member at fireship io to

get access to the new firebase security master course where you'll learn all kinds of advanced techniques for real-world applications thanks for watching and i will see you in the next one



[Music] hi i'm rachel and i'm sam welcome to the next episode in our series about making your app safe and secure today we want to give you the tools you need to start thinking about app security and user privacy from the very beginning of app development let's review how firebase security is different from security in a traditional app in a traditional architecture there's a client a server and a storage layer the server acts as a natural security check because you control the server and the

code that's running on it it's a trusted environment and the server makes all the requests to the database in firebase there's no server and the client connects directly to the storage layer you don't control the clients so those aren't trusted environments so how will you prevent a user from reading all the data or overwriting all of it how do you enforce that for example in this to do app i can only see my to-do's and you can only see your to-do's the answer is security rules security

rules let you specify which parts of the firebase backend each client can access security rules are executed on every request a request from a client will go through security rules and if security rules says the request is allowed the back end will send the response otherwise they'll get a permission denied error for example you can write a simple rule that says signed in users can create a new document if they're listed as the owner or you could create a more complicated role that a user can only modify a

comment they've made if they have a karma score over 15 if they made the original comment less than two hours ago and if the modified comment is shorter than the original comment you can create all sorts of different conditions for who can read and edit different kinds of documents but whether they are simple or complicated it's essential that you write security rules ideally start writing rules as soon as you start writing your app because security rules will change how you structure your data

so we'll cover the tools new and old that let you do that let's dive into what security rules look like first match statements define which parts of the back end the following rules will apply to for firestore the match statements end at the document level we include the collection and then make the document id variable by putting it in curly braces this rule will apply to all the top level documents in this collection and the document id will be available within the block for storage the match statements include

bucket names and end at the file level when you're writing rules you want to avoid global rules rules that match the entire database or bucket instead you want to write rules that are tailored to each kind of document granular rules act like a schema you can see what fields you have in each document what the types of each field should be and who has access to it next we define a specific permission the available permissions for firestore are create update delete get and lists additionally read is an alias for both

get and list and write is an alias for create update and delete if you write overlapping rules for example a rule that allows creates and a rule that allows rights if any rule evaluates to true the user will have access rules aren't filters if any rule grants access access is granted on the whole request a way to avoid mistakes is to have each document match only one rule finally each rule needs a condition if you want to lock down your app entirely the condition could be as simple as false but the options for

conditions are limitless there are two important objects you use over and over again in the conditions for your security rules first the resource object is the document that the user is trying to access as it's currently written in the database if this is the create method the resource object will be empty if i structured the firestore document for an item in my to-do list to have an owner-uid field i can write a rule that checks this uid i want to compare it to the id of the user who is making the request for that

i'll need the other important object in rules conditions the request object the request object contains all the attributes related to the request including the path or the query that's been accessed the new or updated resource that the request wants to write and in the auth object details about the user who's making that request so i can finish my role by comparing the user id i have in the database to the id of the user who's making the request these aren't the only types of objects

and functions that you have access to but these are the most important we've linked to the ref docs in the description so you can dive in more and you can use custom functions and local variables in your security rules to make your code easier to read and reduce duplication when you have conditions that are repeated again and again across your rules you can pull those into a function instead of repeating this logic you can now call the function here i've replaced all the conditions that made an exception for site admins

with a call to one single function within functions you can also create local variables using the keyword let this is particularly handy for writing readable code this hasn't changed the logic at all but it's much more readable that's the syntax of rules next let's think about what kinds of security rules that you want to write you can make it a lot easier on yourself if you start thinking about security rules as soon as you start thinking about the data that you want to save who should be able to read create update

or delete this final data if you're about to save a document where some fields are public and some are private use a subcollection to put them in separate documents remember firestore rules apply to documents so creating two documents in sub-collections means that you can write two different security rules for each of them here i've written two security rules one for the data that needs to be private and one for data that other people in the app need to be able to read we've linked in the notes to a video on

how to model your data in firestore security rules can also contain data validations access control rules are absolutely required because they protect your users data from malicious actors by contrast validations are here to make your life easier by enforcing the types and constraints of the data being entered into your database for example i expect this data to always be an integer between 1 and 24 so to prevent any funny business i make that a requirement to save the data similarly here i enforce which fields

are required there are limits to what you can do with validations and rules you'll still want to use client-side validations for most things as well because they will give the user feedback that they need to change something and if you're making any rights from firebase functions or another trusted environment the admin sdk skips firebase rules entirely so make sure that whatever it's writing matches your validations here i've made the created at timestamp and owner immutable people can update

this document but if someone tries to change those particular values the write will fail map diffs are a relatively new feature to security rules they let you compare original values to updated values i'm comparing the request.resource.data to the already saved resource.data and then checking to make sure that my immutable fields are both unchanged in the right map diffs are great for this kind of thing we know that writing security rules can fill really high stakes you don't want to make a mistake that grants access to

someone who shouldn't have it we've created several tools for you to experiment with uh and then even libraries for you to write automated tests against your security rules the most important tool is the firebase emulator suite a local emulation of firebase backend services with the emulators you can test your security rules either manually by clicking around or with automated tests using the rules unit testing library if you're writing tests in javascript in my automated test here i've stubbed

out the user attributes i want to test and then in each test i make a specific sdk call and i declare if that request should succeed or fail i've added these tests to my ci setup to make sure i won't accidentally break my security rules in the future we've included in the links below a video about how to get these kinds of tests set up to run as github actions the emulator suite is also a great place to build and debug without slowing down requests two features worth highlighting are the debug function and the requests

monitor the debug function lets you inspect any value in your rules file i can call debug on any expression in my rules i'll add it here around request.time and make sure that it's in the format i expect and when i run my test it prints to standard out requests monitor is a cool new feature we just released it lets you see the requests coming into the firestore emulator in real time and allows you to drill down into any request you can see all the attributes of the request and what happened during rules

evaluation this tool is especially handy when you're writing your rules and you're not sure which fields the rules have access to for example you can see all the fields attached to the auth object in request.app when you start building your app you can watch the request monitor and see all the parameters that are coming in as part of the request and start writing rules from the very beginning that's it for this video my final tip is that i recently released a codelab to help you get up and running on rules and

it's linked in the description below the co lab covers how to think through and write a variety of rules it takes about an hour and it will really level you up in how you're thinking about and writing your security rules sam what's your final tip let me see uh security rules are business logic like the rest of your app's code so it's important you treat them like that when you make changes to security rules review them like you would the rest of your code a link to our guide on how to review

security rules is below the video to recap our tips avoid global rules rarely do you want one permission for every document in your database rules aren't inherited through subcollections write separate rules for documents that are in sub-collections rules don't act as filters if any rule grants access that user will have access all client requests go through security rules but requests from trusted environments use the admin sdk and they bypass security rules avoid duplication meaning both avoid

repeating logic and avoid overlapping rules use the emulator suite and the tools there for debugging and testing your rules like the debug function and request monitor treat your security rules like the rest of your code test them code review them and check them in that's all thanks so much for listening in we'll see you next time when rosalind gives us the lowdown on firebase appcheck


Many apps need to give different levels of data access to different types of users. For example, you might have an app for teachers and students. Teachers need to see all the student data, add grades, and manage exams, while students only need to see their own grades and take exams.

A news app needs readers to be able to view articles, editors to add their own stories, and admins to control all the content. A movie review app might have lots of users leaving comments, some moderators adding movie info, and posting reviews.

This is a pretty common setup, and there are lots of ways to handle it. In today’s Firecast, I’m showing one solution. When you’re dealing with different user roles in your app, you have a few options.

You can use security rules and roles you manage yourself. For example, if you’re using Cloud Firestore, you can have a collection listing user roles, then check in your security rules if a user has the right permissions before letting them write data. This works and sometimes is the best choice, depending on the kinds of roles you have.

But you can see how writing a get request for each role can make your rules super complex. Plus, these database reads add up in costs and quota. You’ll also need separate rules for the documents that hold role info.

Another option is to set up separate projects and databases for each user type.

They can share data securely through a backend, syncing what two apps need to access. This is a great use case for Cloud Functions because each app has its own database, so they can have separate security rules tailored for different user types. That's a solid solution. But what if you have lots of different roles, or users can have multiple roles? Keeping data synced across multiple databases can get complicated fast. So both options work, but there’s another solution that might fit better: Firebase Auth Custom Claims. Let me explain what that means. No matter how you log in with Firebase Auth — whether it’s Firebase’s email/password, third-party providers like GitHub or Google, or your own custom auth tokens — at the end you get a Firebase ID token. This token identifies your user for Firebase services. The Firebase Auth ID token is basically a token with extra info about the user, like their email and display name. Beyond that, you can add custom claims to the token to enable different user roles. Custom claims are something you set up on the server side.

Key-value pairs set for each user can be defined as permissions that grant access to data resources—just like what you need for apps with teachers and students. They also allow multi-level access to data, similar to apps with paying and non-paying users. 

Since you know you can add custom permissions for users, it might seem like a good idea to add all kinds of data to these custom permissions. Maybe you want to add a home address, extra photo URLs, or a profile description. But that’s not what custom claims are meant for.

If your user’s ID token carries a lot of extra data, it has to be sent back and forth every time it’s used, which isn’t a good experience for your users. So generally, you don’t add extra properties directly to the Firebase ID token. Instead, you store extra attributes in the Realtime Database or Cloud Firestore and query them when needed.

Also, custom claims have a total size limit of 1000 bytes. If you hit that limit, you’ll need to rethink how you’re using claims, because managing that many claims in security rules can get tricky.

Keeping all that in mind, let’s get back to how to use these claims to grant limited access to data. I’ll use a movie-rating app example called Fire Flicks. If you’re interested in custom claims, there’s a codelab that goes along with the Fire Flicks app.

You really should check out Fire Flicks. I hope that some selected moderators can add new movies to the database. I want any user to be able to comment on movies, but I don’t want them to add movies to the database. I can use custom claims to tell regular users and moderators apart by adding a claim to the moderator’s ID token. I definitely don’t want to do this on the client side. Instead, I can send a request to my server to make these changes for me. Whether it’s a server you built yourself or a serverless solution like Cloud Functions, you want to limit who can interact with these services. Luckily, you can manage and access claims from your server using the Firebase Admin SDK. I’ll show you how to use the Admin SDK in JavaScript to get and set custom claims. Specifically, I’ll use TypeScript, but you can also use the Admin SDKs for Python, Go, or Java to set claims. I’m not going to cover the installation process in detail right now, but if you need that info, I’ve included a Firecast link that guides you through installing and getting started with the Admin SDK. I’ll declare a function called grantModeratorRole that takes one parameter—the user’s email. This is the email of the user we want to grant moderator permissions to.

First, I’ll use the getUserByEmail function from the Firebase Admin SDK to get the Firebase user with the given email. Then, I check the user’s current permissions using the customClaims parameter. If the user already has admin rights, I’m done here and just return. If they don’t, I call the setCustomUserClaims function from the Admin SDK to add the permissions. You can add multiple claims at once, but keep in mind there’s a 1000-byte limit. 

So, I just showed you how to add custom claims using the Admin SDK. After that, you can call the server from the client to add claims as needed. But the code I showed you earlier is missing an important part: I need a way to make sure only authorized users can add claims to others. 

I can do this by passing the requesting user’s Firebase ID token. Then, on the server side—whether in Cloud Functions or any protected environment I’m using—I can verify if that user is authorized to elevate other users. 

Let’s add this check to our server code. To check if the requesting user has permission, I need to be able to inspect the claims on their Firebase ID token. One option is to include this info...

Sent as a header in the request. If you want to see what it looks like, check out the codelab link I put below. Today, I’m going to show you how to do this using a callable function. The reason is, when you call a callable function, you can access info about the user making the request from the function’s context. This lets me do things like check if the user has a moderator claim by using context.auth.token.moderator. If that moderator claim isn’t set to true, I return an error that gets sent back to the client. Then, if the user does have moderator rights, I pass the email from the request to the function I showed you earlier that grants moderator roles. So far, we’ve seen how to set custom claims on users and how to use the Admin SDK to check for those claims in your own backend. But the coolest use of custom claims is probably with Firebase security rules. Since user claims can be accessed from security rules, you can use them to restrict access to data in Cloud Firestore, Realtime Database, and Cloud Storage based on those claims. Let’s look at an example. Rules in Cloud Firestore and Cloud Storage follow the same format. I’m assuming you’re already familiar with security rules, but if you want to learn more, just let me know.

Please check out the guide link I’ve put below. There’s a lot to cover in the security rules, so I’m not going to go through everything here. I want to focus on using custom claims to keep your paths secure. In Cloud Firestore and Cloud Storage, you use request.auth.token to access claims. Any existing claim can be accessed using its key. So for Firestore and Storage, I can use request.auth.token.moderator to access a claim called "moderator."  

In Fire Flicks, movie documents are stored in a collection called "movies." I want to make sure that authenticated users can read the movies, but only moderators can write to them. The rules look something like this.  

By the way, if you’re using the Realtime Database, the rules are a bit different — they look like this.  

Custom claims are a great way to implement role-based Firebase data access. But wait, there’s more! Custom claims can also be accessed on the client side, which lets you customize what users see based on their roles.  

Here are some simple examples showing what this looks like on iOS, Android, and the web. Every client auth SDK has a way to get claims from the Firebase ID token. In Swift, that’s done with getIDTokenResult.

Don’t confuse it with the getIDtoken function. They work similarly, but getIDtoken passes an encoded token. If I find the moderator claim, I show the UI with moderator privileges. If not, I show the regular user interface. On Android, I use getIDtoken to get the ID token. I call getClaims to get all the claims and look for the one I need—in this case, the moderator claim. Just like on iOS, I update the UI based on whether the user is a moderator. For the web, I call getIDtokenresult, which returns a promise that resolves to an ID token result object. This object has the ID token string, helper properties to get different data linked to the token, and all the decoded payload claims. I check for the moderator claim and show different UI depending on the result. Most likely, just showing or hiding content based on the presence of a claim will work fine for most users. But as a developer, you know this isn’t a secure way to protect data. For example, on a web app, anyone can open the browser’s developer tools and check the code to see what’s going on under the hood. Custom claims on the client side should only be used to create a better user experience—they’re not secure. To make sure—even for smart developers like you...

You also can’t access those moderator data. You need to add security features on the backend too, just like I showed earlier. Use Firebase security rules and treat custom claims on the client side as a way to guide users within your app, not as a security measure. This is super important—let me say it again: relying only on custom claims on the client side is not secure. The real protection comes from security rules. When your rules are set up properly, even if someone reverse-engineers your app and finds the moderator features, they still can’t write to the collections reserved for moderators because their Firebase ID token won’t have the moderator claim.

So, by now, I bet you’re pretty much a pro at Firebase Auth custom claims. But before you go and build an awesome custom user experience with claims, keep a few things in mind: custom claims need to be applied in a secure backend environment. Otherwise, users could add claims themselves, which defeats the whole purpose. You can use any server or serverless solution you like. You might want to combine claims on both frontend and backend to create the best user experience while keeping your data safe.

If a user is already logged in and you add a custom claim, their token won’t have that claim until it’s refreshed. And the opposite is true too—if you remove a custom claim to revoke access, the existing token won’t lose access immediately.

Every client SDK has a method to refresh the Firebase token, so you can use that wherever it makes sense. Cloud Firestore, Realtime Database, and Cloud Storage update permissions based on changes to the user's UID, not by refreshing the token. This means that even if you refresh the token, your security rules won’t reflect any changes in access. Logging out changes the UID to null, so when the client logs back in, Firebase products check the permissions of the latest token. Lastly, setting a custom claim with the same key as an existing one will always overwrite it. This might be what you want, but if not, it could cause problems. Alright, now you’re ready to use Firebase Auth custom claims to customize data access. I’d love to hear how you’re using claims in your own apps—drop a comment below or hit me up on Twitter @ThatJenPerson. If you found this video helpful, be sure to subscribe to the Firebase channel for more great content. Thanks so much for watching, and we’ll see you on future Firecasts!


[MUSIC PLAYING]  ROSALYN TAN: Hi, I'm Rosalyn, a software engineer at Firebase. SHRUTI PADAMATA: And I'm Shruti, a software engineer at Firebase. ROSALYN TAN: And today, we'll be talking about how you can build a more secure application right from the start using Firebase. Let's say that you, a cat lover, have a grand new idea for a game called [? Furdle, ?] where you score points by clicking on as many cats as you can in a minute. Players can then enter their name to have their score submitted to a high score leaderboard.

SHRUTI PADAMATA: That sounds like a great game. ROSALYN TAN: But a few weeks after you launch your game, feedback starts rolling in. And not all of it is good. One of your users complains that someone is submitting low scores under their name. Another user asks why their high scores have been deleted. And to make matters worse, you realize that someone has been cheating by writing impossible high scores directly to your backend. SHRUTI PADAMATA: What a disaster. However, this could have been easily prevented by proactively

considering security concerns. Thinking about security can be intimidating. And it might be tempting to put it off until later, after the fun parts of coding your application features are done. However, it's important to be thinking about security from the very beginning. And Firebase makes it easy to do so. With Firebase Authentication, Firebase Security Rules, and Firebase App Check, you can help protect your services, your users, and their data from malicious actors. ROSALYN TAN: So let's consider where [? Furdle ?] went wrong.

One of the first problems the game ran into was that users could submit their scores under any identity, resulting in confusion. This is where Firebase Authentication can come in. As the name suggests, Firebase Authentication allows your users to sign in, or authenticate, within your application. So they have an identity that can be associated with their activity in your app. When users authenticate with your Firebase project, they receive a unique user ID. With that user ID, you can associate your users

with their data by storing the user ID as a field in Database Documents or in the database path itself. Now, instead of letting [? Furdle ?] players submit their scores under any identity they choose, their scores can instead be mapped to their authenticated user identity. Setting up Firebase Authentication is super simple in the Firebase console. First, you enable Firebase Authentication. And then you can enable whatever authentication providers you want to support in your application, for example, Google Sign-in, Facebook Login, Sign

In with Apple, or Phone Authentication. If you choose to enable email password sign-in, we recommend that you also enable the email link setting so that you can verify that the email address belongs to your user. For integrating client side authentication logic to your applications, Firebase provides Firebase UI Auth, a drop-in authentication library available on Android, iOS, and web that implements complete user flows for all of Firebase Authentication supported sign-in methods. If you want more control over the sign-in experience,

Firebase also provides a Firebase authentication SDKs for Android, iOS, web, C++ and Unity platforms, allowing you to implement your own authentication flows to suit your needs. With Firebase authentication integrated into [? Furdle, ?] players can now be sure that their high scores are attributed to them. SHRUTI PADAMATA: Name collisions on the high score leaderboard weren't the only problem that [? Furdle ?] ran into, though. As you may recall, another [? Furdle ?] loser provided feedback that their scores

kept disappearing from the leaderboard, deleted by malicious users. This is definitely not ideal, but can be easily prevented by using Firebase Security Rules. Security Rules are rules that you write that define custom conditions to authorize users access to specific parts in your Firebase databases. Security Rules are enabled by default for all the Firebase database products, although with slight variations in the syntax. Rules for Cloud Firestore and Cloud Storage for Firebase use a language based on the common expression language

while Realtime Database rules use a syntax that looks like JavaScript in a JSON structure. The syntax of both will look and feel familiar to anyone who has worked with JavaScript. Combined with Firebase Authentication, you can use Security Rules to build user and attribute based access systems to help keep your users' data safe. However, your security rules are only as secure as you write them. So let's take a look at how to set up some secure rules for [? Furdle. ?] Security Rules should be in mind early

on when you're thinking about the shape of your data. Security Rules apply to entire documents, not individual fields. So make sure to keep that in mind when structuring your data. First, let's consider the data that [? Furdle ?] may store. A simple [? Furdle ?] database might just store a collection of games documents, where each game has a player ID field and a score field. While players can view all the game entries on the high score leaderboard, they should only be able to create a game entry for their own player

ID and delete game entries that they created. Now, let's build out Security Rules for our data. Every rules file starts with this boilerplate that specifies the version and the service. Within that, we can write statements to match specific document paths. The curly braces around gameId mean that this is a variable we can use in our rules if we need to. Within each match statement, we can specify permissions and conditions. For example, anyone playing should be able to read the data. So we just check that the user is signed in.

And anyone is allowed to create a game, as long as they are the player listed on the game. Now, let's run this out with the condition to delete. Only the player listed on the game can delete a game entry. You can also use the rules to validate user data. For example, ensuring that the data contains required attributes or that the data size does not exceed limits. Here, we verify that in order to create a new game document in [? Furdle, ?] the playerId field and score fields must be populated.

Another useful construct in Security Rules are functions, which allow you to wrap sets of conditions and re-use them in multiple places. Here, we define the isAdmin function, which is used in both the Delete and the Update rule. One thing to be careful of, though, rules are applied as or conditions and not and conditions. So it's important to avoid broader rules that grant access using global match statements or wild cards. These can grant access to your data, even when there are more granular roles

for a particular document that wouldn't grant the access. To make it easier to start off, when you're first developing your app, Security Rules can be enabled in test mode with open read/write access for 30 days. You can continue to use Cloud Firestore, Cloud Storage, and Realtime Database free of charge until you reach the no cost usage limit after 30 days by updating your security rules. Be sure to update your rules to enforce proper conditions before pushing your app to production. As you can see, Firebase Authentication

is only part of the security story. While Firebase authentication allows you to know who your users are, Firebase Security Rules and Authorization a powerful mechanism to write granular access conditions and help you ensure that your users only have access to the appropriate data. ROSALYN TAN: Of course, we can't forget the last issue that [? Furdle ?] ran into. A malicious user, wanting to cheat their high score, bypassed the game and submitted scores directly to the [? Furdle ?] database.

Luckily, Firebase App Check can help with that. Firebase App Check protects access to your services by attesting that traffic to your backends is coming from your application. It does so by utilizing platform specific attestation providers, like Play Integrity on Android, App Attest on iOS, and reCAPTCHA on web, as well as custom attestation provider support so that you can better protect your backends no matter what platform you use to build your app. App Check is also easy to set up in the Firebase console.

You'll just need to register your application to use App Check by providing some information in order to correctly configure the attestation providers for each platform. For example, to configure the reCAPTCHA V3 provider for a web application, you'll need to enter your reCAPTCHA secret key. Next, you'll want to configure App Check in your application code. Firebase provides Firebase App Check SDKs for Android, iOS, and web platforms. And it's super simple to add App Check integration

into your application with only a few lines of code. If you're adding App Check to your application right at the beginning of your application development, which we recommend, then you can turn on App Check enforcement right away, since you won't have any old application versions without App Check integration in use. However, if you're adding App Check to an already launched app, then you can instead monitor App Check request metrics to make a decision of when to enforce App Check based on how

many verified, outdated client, unknown origin, and invalid requests you have. Firebase App Check is currently integrated with Cloud Firestore, Cloud Storage, Realtime Database. And Cloud Functions. With more product integrations to come. Beyond Firebase, App Check also makes it easy to help protect the API endpoints on your own self-hosted backends or custom resources with the help of the Node.js Admin SDK. App Check also works great with services like Apigee and Cloud Run to add that extra layer of protection,

letting you rest easy. With Firebase App Check, [? Furdle ?] users can be confident that the scores they see on the leaderboard are from fellow players, instead of cheaters using a command line. SHRUTI PADAMATA: And there you have it. See how by using Firebase Authentication, Firebase Security Rules, and Firebase App Check, [? Furdle ?] could have been made more secure and avoided the issues that they ran into during its launch. ROSALYN TAN: A question developers may have is what exactly is the difference between Firebase

Authentication, Firebase Security Rules, and Firebase App Check. We hope that following [? Furdle's ?] security journey has helped clarify things for you. But just in case, here's a quick summary of how each of these products helps protect different aspects of your application. Firebase Authentication and Firebase Security Rules deal with user authentication and authorizing user access to data. They help protect your users from malicious actors. Firebase App Check, on the other hand, focuses on application identity, rather than user identity

to protect you, the developer, from unwanted usage outside of your app. Together, Firebase Authentication Firebase Security Rules, and Firebase App Check work together to help protect and secure your Firebase application. SHRUTI PADAMATA: Thank you for joining us to learn about how to build secure Firebase applications right from the start. Happy developing. [MUSIC PLAYING]
